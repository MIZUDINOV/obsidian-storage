Реактивные паттерны — это переиспользуемые решения для часто встречающихся проблем, использующие реактивное программирование. За всеми этими паттернами стоит новый способ мышления, новая архитектура, новые стили кодирования и новые инструменты. Именно на этом основана вся книга — на полезных реактивных паттернах в приложениях Angular.

  

Я знаю, что вы не терпите приступить к написанию вашего первого реактивного паттерна в Angular, но прежде чем это сделать, и чтобы помочь вам в полной мере использовать все паттерны RxJS и применять реактивную парадигму, мы начнем с подробного объяснения основ и подготовки фундамента для последующих глав.

  

Начнем с базового понимания реактивной парадигмы, ее преимуществ и проблем, которые она решает. Лучше всего, давайте наденем реактивное мышление и начнем думать реактивно. Мы начнем с выделения основ и преимуществ реактивной парадигмы. Затем мы объясним мраморную диаграмму и почему она полезна. Наконец, мы подчеркнем использование RxJS в Angular.

  

Понимание основ реактивной парадигмы невероятно важно. Это гарантирует, что вы правильно разберетесь с базовыми понятиями, поможет понять полезность реактивного подхода и, следовательно, поможет определить, в каких ситуациях его лучше использовать.

  

В этой главе мы рассмотрим следующие темы:

  

- Исследование основ реактивного программирования

- Изучение мраморной диаграммы (нашего секретного оружия)

- Подчеркивание использования RxJS в Angular

  

## Технические требования

  

Эта глава не требует настройки окружения или установки. Все фрагменты кода в этой главе — это примеры для иллюстрации концепций, поэтому вам не понадобится репозиторий кода для следования. Однако, если вас это интересует, код книги можно найти по адресу: [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition).

  

Эта книга предполагает, что у вас есть базовое понимание Angular и RxJS.

  

> **Примечание**  

> В книге используется новый сайт документации Angular — angular.dev. Предыдущий сайт документации, angular.io, скоро будет устаревшим. Следите за последними обновлениями и ресурсами, используя ссылку на документацию.

  

## Исследование основ реактивного программирования

  

Реактивное программирование — одна из основных парадигм программирования, используемых разработчиками по всему миру. Каждая парадигма решает определенные проблемы и имеет свои преимущества. По определению, реактивное программирование — это программирование с асинхронными потоками данных и основано на паттерне наблюдателя. Давайте разберем эти основы реактивного программирования!

  

### Потоки данных

  

Потоки данных — это основа реактивного программирования. Все, что может изменяться или происходить со временем (и вы не знаете, когда именно), представлено как асинхронные потоки, такие как события, уведомления и сообщения. Реактивное программирование заключается в реакции на изменения, как только они происходят!

  

Отличный пример потоков данных — это события пользовательского интерфейса. Предположим, у нас есть HTML-кнопка, и мы хотим выполнить действие каждый раз, когда пользователь нажимает на нее. Здесь мы можем рассматривать событие клика как поток:

  

```html

<!-- HTML код -->

<button id='save'>Сохранить</button>

```

  

```javascript

// JS код

const saveElement = document.getElementById('save');

saveElement.addEventListener('click', processClick);

  

function processClick(event) {

    console.log('Привет');

}

```

  

Как показано в приведенном фрагменте кода, чтобы реагировать на событие клика, мы регистрируем слушатель событий (`EventListener`). Затем каждый раз, когда происходит клик, вызывается метод `processClick` для выполнения побочного эффекта. В нашем случае мы просто выводим "Привет" в консоль.

  

Как вы могли заметить, чтобы реагировать на происходящее и выполнять побочный эффект, нужно слушать потоки, чтобы получать уведомления. Чтобы приблизиться к реактивной терминологии, вместо "слушать" мы можем сказать "наблюдать". Это приводит нас к паттерну наблюдателя, который лежит в основе реактивного программирования.

  

### Паттерн наблюдателя

  

Паттерн наблюдателя основан на двух главных ролях — издателе и подписчике:

  

- **Издатель** поддерживает список подписчиков и уведомляет их или распространяет изменения каждый раз, когда происходит обновление.

- **Подписчик**, с другой стороны, выполняет обновление или выполняет побочный эффект каждый раз, когда получает уведомление от издателя.

  

Паттерн наблюдателя иллюстрируется следующим образом:

![Рисунок 1.1 - Паттерн наблюдателя](observer-pattern.png)

  

Чтобы получать уведомления об обновлениях, нужно подписаться на издателя. Аналогия из реального мира — это новостная рассылка; вы не получите никаких писем от конкретной рассылки, если не подпишетесь на нее.

  

Это приводит нас к строительным блокам RxJS, которые включают:

  

- **Observables**: Это представление асинхронных потоков данных, которые уведомляют наблюдателей о любых изменениях.

- **Observers**: Это потребители потоков данных, испускаемых Observables.

  

RxJS сочетает паттерн наблюдателя с паттерном итератора и функциональным программированием для обработки и управления асинхронными событиями. Это было напоминание об основах реактивного программирования, и важно знать, когда применять реактивную реализацию, а когда ее избегать.

  

В целом, всякий раз, когда вам нужно обрабатывать асинхронные задачи в вашем приложении Angular, всегда думайте о RxJS. Основные преимущества RxJS по сравнению с другими асинхронными API:

  

- RxJS упрощает работу с программами, основанными на событиях, асинхронными вызовами данных и обратными вызовами.

- Observables гарантируют консистентность. Они испускают множество значений со временем, позволяя потреблять непрерывные потоки данных.

- Observables ленивы; они не выполняются, пока вы не подпишетесь на них. Это помогает писать декларативный код, который чист, эффективен и легко понимаем и поддерживаем.

- Observables могут быть отменены, завершены и извлечены в любой момент. Это имеет смысл во многих реальных сценариях.

- RxJS предоставляет множество операторов в функциональном стиле для манипуляции коллекциями и оптимизации побочных эффектов.

- Observables передают ошибки подписчикам и предоставляют чистый способ обработки ошибок.

- RxJS позволяет писать чистый и эффективный код для обработки асинхронных данных в вашем приложении.

  

Теперь, когда мы рассмотрели основы реактивного программирования и подробно описали основные преимущества RxJS, давайте изучим мраморную диаграмму, которая очень удобна для понимания и визуализации выполнения Observable.

  

## Изучение мраморной диаграммы (нашего секретного оружия)

  

RxJS поставляется с более чем сотней операторов — это одни из строительных блоков RxJS, полезные для манипуляции потоками. Все реактивные паттерны, которые будут подробно рассмотрены позже в этой книге, основаны на операторах, и когда дело доходит до объяснения операторов, лучше использовать визуальное представление — вот где вступают в игру мраморные диаграммы!

  

Мраморные диаграммы — это визуальные представления выполнения оператора, которые будут использоваться во всех главах для понимания поведения операторов RxJS. На первый взгляд они могут показаться сложными, но они удивительно просты. Нужно лишь понять анатомию диаграммы, и тогда вы сможете легко их читать и интерпретировать.

  

Мраморные диаграммы представляют выполнение оператора, поэтому каждая диаграмма включает следующее:

  

- **Входной Observable(ы)**: Представляет один или несколько Observables, переданных в качестве входных данных оператору.

- **Оператор**: Представляет оператор, который будет выполнен с его параметрами.

- **Выходной Observable**: Представляет Observable, созданный после выполнения оператора.

  

Выполнение иллюстрируется следующим образом:

![Рисунок 1.2 - Выполнение оператора](operator-execution.png)

  

Теперь давайте увеличим масштаб на представление входных/выходных Observables:

![Рисунок 1.3 - Элементы мраморной диаграммы](marble-diagram-elements.png)

  

Элементы этих диаграмм включают следующее:

  

- **Временная шкала**: Observables — это асинхронные потоки, которые производят данные со временем. Поэтому представление времени имеет решающее значение в мраморной диаграмме, и оно представлено стрелкой, идущей слева направо.

- **Мраморные значения**: Это значения, испускаемые Observables со временем. Они представлены цветными кругами.

- **Статус завершения**: Вертикальная линия (`|`) представляет успешное завершение Observables.

- **Статус ошибки**: Символ `X` представляет ошибку, испущенную Observable. После этого ни значения, ни вертикальная линия, представляющая завершение, не будут испущены.

  

Это все элементы, которые вам нужно знать. Теперь давайте соберем все части вместе в реальной мраморной диаграмме:

![Рисунок 1.4 - Пример мраморной диаграммы для пользовательского оператора](custom-operator-marble.png)

  

Как вы могли догадаться, у нас есть пользовательский оператор `divideByTwo`, который будет испускать половину каждого полученного числа. Когда входной Observable испускает значения `4` и `8`, выходной Observable производит `2` и `4` соответственно.

  

Однако, когда испускается значение `R`, которое не является числом, возникает ошибка, указывающая на ненормальное завершение. Этот случай не обрабатывается в коде оператора. Входной Observable продолжает испускать значения и затем успешно завершается. Однако значение никогда не будет обработано, потому что после ошибки поток закрывается.

  

На этом этапе мы рассмотрели все элементы, составляющие мраморную диаграмму. Вы сможете понять операторы, используемые в следующих главах. Теперь давайте прольем свет на использование RxJS в Angular.

  

## Подчеркивание использования RxJS в Angular

  

RxJS фактически является гражданином первого класса в Angular. Он является частью экосистемы Angular и используется во многих функциях для обработки асинхронных задач. Вот некоторые примеры таких функций:

  

- Модуль `HttpClient`

- Модуль `Router`

- Реактивные формы

- Эмиттер событий

  

Мы обсудим каждую из этих концепций в следующих подразделах.

  

> **Примечание**  

> Мы рекомендуем взглянуть на [https://angular.dev/overview](https://angular.dev/overview), где вы можете найти дополнительные детали о вышеупомянутых функциях.

  

### Модуль HttpClient

  

Вы, возможно, знакомы с API `HttpClient`, предоставляемым Angular, который используется для связи с сервером по протоколу HTTP. Сервис `HttpClient` основан на Observables, которые управляют всеми транзакциями, что означает, что результат вызова методов API, таких как `GET`, `PATCH`, `POST` и `PUT`, будет Observable.

  

В следующем фрагменте кода представлен пример сервиса Angular, который внедряет сервис `HttpClient` и извлекает данные с сервера с использованием метода `HttpClient.get()`:

  

```typescript

import { Injectable } from '@angular/core';

import { HttpClient } from '@angular/common/http';

import { Observable } from 'rxjs';

import { Recipe } from './model/recipe.model';

  

@Injectable()

export class RecipesService {

  constructor(private http: HttpClient) {}

}

```

  

> **Примечание**  

> Код содержит ссылки на `recipe.model` и `getRecipes()` — в главе 2, "Обзор нашего приложения", вы познакомитесь с приложением для рецептов, над которым мы будем работать на протяжении всей книги.

  

Для тех, кто знаком с HTTP API на основе Promise, вы можете задаться вопросом о преимуществах использования Observables в этом контексте. Для тех, кто не знаком с Promise, Promise — это объекты JavaScript, представляющие конечное завершение (или неудачу) асинхронной операции и ее результирующее значение. Они предоставляют более чистый и структурированный способ работы с асинхронным кодом по сравнению с традиционными подходами на основе обратных вызовов. Однако у Observables есть множество преимуществ по сравнению с Promise, и наиболее важные из них перечислены ниже:

  

- Observables можно отменить, поэтому вы можете отменить HTTP-запрос в любой момент, вызвав метод `unsubscribe`.

- Вы также можете повторять HTTP-запросы, когда возникает ошибка или выбрасывается исключение.

- Ответ сервера не может быть изменен Observables, хотя это возможно при цепочке `then()` в Promise.

  

### Модуль Router

  

Модуль `Router`, доступный в пакете `@angular/router`, использует Observables в событиях маршрутизатора и активированных маршрутах. Рассмотрим оба аспекта.

  

#### События маршрутизатора

  

События маршрутизатора позволяют перехватывать жизненный цикл навигации. Они определены в `Router` как Observables.

  

> **Примечание**  

> Рекомендуем взглянуть на [https://angular.dev/api/router/Event](https://angular.dev/api/router/Event), где вы найдете дополнительные детали о событиях маршрутизатора.

  

Большинство приложений Angular имеют механизм маршрутизации. События маршрутизатора часто меняются со временем, и имеет смысл слушать изменения для выполнения побочных эффектов. Именно поэтому Observables — это гибкий способ обработки этих потоков.

  

Чтобы перехватить все события, через которые проходит маршрутизатор, сначала нужно внедрить сервис `Router`, который предоставляет возможности манипуляции URL. Затем подпишитесь на Observable событий, доступный в объекте `Router`, и отфильтруйте события типа `RouterEvent` с помощью оператора `filter` из RxJS.

  

Следующий пример — это сервис Angular, который внедряет `Router` в конструкторе, подписывается на события маршрутизатора и выводит идентификатор события и путь в консоль:

  

```typescript

import { Injectable } from '@angular/core';

import { Router, RouterEvent } from '@angular/router';

import { filter } from 'rxjs/operators';

  

@Injectable()

export class CustomRouteService {

  constructor(public router: Router) {

    this.router.events.pipe(

      filter(event => event instanceof RouterEvent)

    ).subscribe((event: RouterEvent) => {

      console.log(`Текущее событие: ${event.id} | ${event.url}`);

    });

  }

}

```

  

Это очень простой пример, и вы можете добавить в него практически любое специфическое поведение.

  

#### Активированный маршрут

  

`ActivatedRoute` — это сервис маршрутизатора, который вы можете внедрить в свои компоненты для получения информации о пути маршрута и его параметрах. Многие свойства основаны на Observables. Вот реализация класса `ActivatedRoute`:

  

```typescript

class ActivatedRoute {

  snapshot: ActivatedRouteSnapshot;

  url: Observable<UrlSegment[]>;

  params: Observable<Params>;

  queryParams: Observable<Params>;

  fragment: Observable<string | null>;

  data: Observable<Data>;

  outlet: string;

  component: Type<any> | string | null;

  routeConfig: Route | null;

  root: ActivatedRoute;

  parent: ActivatedRoute | null;

  firstChild: ActivatedRoute | null;

  children: ActivatedRoute[];

  pathFromRoot: ActivatedRoute[];

  paramMap: Observable<ParamMap>;

  queryParamMap: Observable<ParamMap>;

  toString(): string;

}

```

  

Как вы могли заметить, `url`, `params`, `queryParams`, `fragment`, `data`, `paramMap` и `queryParamMap` представлены как Observables. Все эти параметры могут меняться со временем, поэтому имеет смысл слушать эти изменения для регистрации побочных эффектов или обновления значений.

  

Вот пример компонента Angular, который внедряет класс `ActivatedRoute` в конструкторе и затем в методе `ngOnInit()` подписывается на следующие свойства:

  

- Свойство `url` класса `ActivatedRoute`, чтобы вывести текущий URL в консоль.

- Свойство `queryParams` класса `ActivatedRoute`, чтобы получить параметр `criteria` и сохранить его в локальном свойстве `criteria`:

  

```typescript

import { Component, OnInit } from '@angular/core';

import { ActivatedRoute } from '@angular/router';

  

@Component({

  selector: 'app-recipes',

  templateUrl: './recipes.component.html'

})

export class RecipesComponent implements OnInit {

  criteria: string;

  

  constructor(private activatedRoute: ActivatedRoute) {}

  

  ngOnInit() {

    this.activatedRoute.url

      .subscribe(url => console.log('URL изменился на: ' + url));

    this.activatedRoute.queryParams

      .subscribe(params => {

        this.criteria = params['criteria'];

      });

  }

}

```

  

### Реактивные формы

  

Реактивные формы, доступные в пакете `@angular/forms`, основаны на Observables для отслеживания изменений элементов управления формы. Вот обзор класса `FormControl` в Angular:

  

```typescript

class FormControl extends AbstractControl {

  // другие свойства

  valueChanges: Observable<any>;

  statusChanges: Observable<any>;

}

```

  

Свойства `valueChanges` и `statusChanges` класса `FormControl` представлены как Observables, которые вызывают события изменений. Подписка на изменение значения `FormControl` — это способ запуска логики приложения внутри класса компонента.

  

Вот пример, который подписывается на Observable `valueChanges` свойства `FormControl` с именем `rating` ench и просто выводит значение через `console.log(value)`:

  

```typescript

import { Component, OnInit } from '@angular/core';

import { FormGroup } from '@angular/forms';

  

@Component({...})

export class MyComponent implements OnInit {

  form!: FormGroup;

  

  ngOnInit() {

    const ratingControl = this.form.get('rating');

    ratingControl.valueChanges.subscribe(value => {

      console.log(value);

    });

  }

}

```

  

Таким образом, вы получите измененное значение в качестве вывода.

  

### Эмиттер событий

  

Эмиттер событий, являющийся частью пакета `@angular/core`, используется для передачи данных из дочернего компонента в родительский через декоратор `@Output()`. Класс `EventEmitter` расширяет `Subject` из RxJS и регистрирует обработчики для событий, испускаемых этим экземпляром:

  

```typescript

class EventEmitter<T> extends Subject {

  constructor(isAsync?: boolean): EventEmitter<T>;

  emit(value?: T): void;

  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;

}

```

  

Это то, что происходит под капотом, когда вы создаете эмиттер событий и испускаете значение.

  

Следующий блок кода — это пример испускания обновленного значения рейтинга рецепта:

  

```typescript

import { Component, Output, EventEmitter } from '@angular/core';

  

@Component({...})

export class RecipesComponent {

  @Output() updateRating = new EventEmitter<string>();

  

  updateRecipe(value: string) {

    this.updateRating.emit(value);

  }

}

```

  

Таким образом, `EventEmitter` упрощает коммуникацию между компонентами, позволяя одному компоненту испускать пользовательские события, а другому — слушать и реагировать на эти события. Этот механизм играет ключевую роль в обеспечении коммуникации между родительскими и дочерними компонентами, коммуникации между родственными компонентами и даже между несвязанными компонентами в приложениях Angular.

  

> **Примечание**  

> В предыдущих фрагментах кода подписка на Observables была выполнена явно для демонстрации. В реальном примере, если мы хотим подписаться явно, мы должны включить логику отписки. Мы подробнее рассмотрим это в главе 3, "Получение данных в виде потоков".

  

## Резюме

  

В этой главе мы провели вас через основы реактивного программирования и случаи, в которых оно сияет. Затем мы объяснили мраморную диаграмму, которая будет нашим ориентиром для объяснения операторов RxJS во всех последующих главах. Наконец, мы подчеркнули использование реактивного программирования в Angular, иллюстрируя конкретные примеры, реализации и преимущества.

  

Теперь, когда мы разобрались с основами, пришло время начать подготовку и объяснение в следующей главе приложения, которое мы будем строить на протяжении этой книги, где мы реализуем все реактивные паттерны, которые будем изучать постепенно.