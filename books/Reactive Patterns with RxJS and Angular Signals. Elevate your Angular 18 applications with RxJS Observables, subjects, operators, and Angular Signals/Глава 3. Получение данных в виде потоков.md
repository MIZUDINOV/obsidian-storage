В предыдущей главе мы познакомились с приложением для управления рецептами, настроили проект и определили его архитектуру. Теперь пришло время приступить к реализации первого реактивного паттерна — получения данных в виде потоков. Этот паттерн является основой для работы с асинхронными данными в приложениях Angular, и мы используем его для загрузки списка рецептов с сервера.

В этой главе мы изучим, как использовать RxJS для получения данных с помощью `HttpClient` и как эффективно отображать эти данные в интерфейсе с использованием `async` pipe. Мы также разберем, как управлять подписками и избегать распространенных ошибок, таких как утечки памяти. К концу главы вы реализуете функциональность загрузки списка рецептов в нашем приложении и будете готовы к изучению более сложных реактивных паттернов.

Мы рассмотрим следующие темы:
- Реактивный паттерн для получения данных
- Реализация загрузки списка рецептов
- Управление подписками и использование `async` pipe
- Распространенные ошибки и лучшие практики
## Технические требования
Для работы с этой главой вам потребуется следующее программное обеспечение и окружение, настроенное в соответствии с главой 2:

| Программное обеспечение/аппаратное обеспечение | Требования к ОС |
|-----------------------------------------------|-------------------------|
| Angular 17 и выше                              | Windows, macOS, Linux   |
| TypeScript 5.4.2                                    | Windows, macOS, Linux   |
| RxJS 7.8.1                                              | Windows, macOS, Linux   |
| PrimeNG 17.10.0                                  | Windows, macOS, Linux   |
| Bootstrap 5.0.0                                     | Windows, macOS, Linux   |
| Node.js 20.x                                         | Windows, macOS, Linux   |

Убедитесь, что проект настроен, как описано в главе 2, и сервер запущен по адресу `http://localhost:3000`. Код для этой главы доступен в репозитории GitHub по адресу: [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition). Следуйте инструкциям в `README.md` для клонирования и настройки.

> **Примечание**  
> Набирайте код вручную или используйте файлы из репозитория, чтобы избежать ошибок при копировании и вставке. Все примеры кода протестированы с Angular 17 и RxJS 7.8.1.
## Реактивный паттерн для получения данных
Получение данных с сервера — одна из самых распространенных задач в веб-приложениях. В традиционном императивном подходе вы могли бы использовать `Promise` или коллбэки для выполнения HTTP-запросов и последующего обновления пользовательского интерфейса. Однако в реактивном программировании мы рассматриваем данные как **потоки**, которые можно наблюдать и обрабатывать с помощью RxJS.
### Основы паттерна
Реактивный паттерн для получения данных включает следующие шаги:
1. **Создание Observable**: Используем сервис `HttpClient` для выполнения HTTP-запроса, который возвращает `Observable`.
2. **Обработка потока**: Применяем операторы RxJS (например, `map`, `catchError`) для трансформации данных или обработки ошибок.
3. **Подписка или использование `async` pipe**: Потребляем данные либо через подписку в компоненте, либо через `async` pipe в шаблоне для автоматического управления подписками.
4. **Отписка**: Гарантируем, что подписки завершаются, чтобы избежать утечек памяти.

Этот паттерн идеально подходит для Angular, так как `HttpClient` возвращает `Observable` по умолчанию, а `async` pipe упрощает работу с потоками в шаблонах.
### Мраморная диаграмма
Чтобы лучше понять, как данные передаются в виде потока, рассмотрим мраморную диаграмму для HTTP-запроса:

```

Входной Observable (HTTP-запрос): ----a-| (где a — массив рецептов, | — завершение)

Оператор: map (преобразование данных)

Выходной Observable:             ----b-| (где b — преобразованный массив)

```

Здесь `HttpClient.get()` создает `Observable`, который испускает одно значение (результат запроса) и завершается. Если возникает ошибка, поток завершается с ошибкой:

```

Входной Observable: ----X (где X — ошибка)

Оператор: catchError

Выходной Observable: ----e-| (где e — обработанная ошибка)

```

Мы будем использовать эти концепции для реализации загрузки списка рецептов.
## Реализация загрузки списка рецептов
Давайте реализуем функциональность загрузки списка рецептов с сервера в нашем приложении. Мы создадим сервис для выполнения HTTP-запросов, компонент для отображения данных и используем `async` pipe для управления потоками.
### Шаг 1: Создание сервиса
Создайте файл `src/app/recipes/recipes.service.ts` и реализуйте сервис `RecipesService` для получения данных:

```typescript
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { Recipe } from './recipe.model';

// Базовый URL сервера
const API_URL = 'http://localhost:3000/api';

@Injectable({
  providedIn: 'root'
})
export class RecipesService {
  constructor(private http: HttpClient) {}
  // Получение списка всех рецептов
  getRecipes(): Observable<Recipe[]> {
    return this.http.get<Recipe[]>(`${API_URL}/recipes`).pipe(
      map(response => response), // Простое преобразование ответа (можно расширить)
      catchError(this.handleError) // Обработка ошибок
    );
  }

  // Обработка ошибок
  private handleError(error: any): Observable<never> {
    console.error('Произошла ошибка:', error);
    return throwError(() => new Error('Не удалось загрузить рецепты. Попробуйте позже.'));
  }
}
```

Этот сервис:
- Использует `HttpClient` для выполнения GET-запроса к конечной точке `/api/recipes`.
- Применяет оператор `map` для обработки ответа (в данном случае просто возвращает его, но можно добавить трансформацию).
- Использует `catchError` для обработки ошибок, возвращая пользовательское сообщение об ошибке.
### Шаг 2: Создание компонента
Создайте компонент для отображения списка рецептов с помощью команды Angular CLI:

```

// Создание компонента

ng generate component recipes/recipes-list

```

Обновите файл `src/app/recipes/recipes-list/recipes-list.component.ts`:

```typescript
import { Component, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { Recipe } from '../recipe.model';
import { RecipesService } from '../recipes.service';
  
@Component({
  selector: 'app-recipes-list',
  templateUrl: './recipes-list.component.html',
  styleUrls: ['./recipes-list.component.scss']
})
export class RecipesListComponent implements OnInit {
  recipes$!: Observable<Recipe[]>;

  constructor(private recipesService: RecipesService) {}

  ngOnInit(): void {
    this.recipes$ = this.recipesService.getRecipes();
  }
}
```

Этот компонент:
- Объявляет свойство `recipes$` как `Observable<Recipe[]>`.
- В методе `ngOnInit` вызывает `getRecipes()` из сервиса и присваивает результат `recipes$`.
### Шаг 3: Обновление шаблона
Обновите файл `src/app/recipes/recipes-list/recipes-list.component.html`, чтобы отобразить список рецептов с использованием `p-table` из PrimeNG и `async` pipe:

```html
<p-table [value]="(recipes$ | async)!" [tableStyle]="{ 'min-width': '50rem' }">
  <ng-template pTemplate="header">
    <tr>
      <th>Название</th>
      <th>Категория</th>
      <th>Рейтинг</th>
      <th>Дата создания</th>
    </tr>
  </ng-template>
  <ng-template pTemplate="body" let-recipe>
    <tr>
      <td>{{ recipe.title }}</td>
      <td>{{ recipe.category }}</td>
      <td>{{ recipe.rating }}</td>
      <td>{{ recipe.createdAt | date: 'short' }}</td>
    </tr>
  </ng-template>
</p-table>
```

Здесь:
- `recipes$ | async` автоматически подписывается на `Observable` и извлекает данные.
- `!` (non-null assertion) указывает TypeScript, что данные не будут `null`.
- Компонент `p-table` отображает рецепты в виде таблицы.
### Шаг 4: Добавление маршрута
Обновите файл `src/app/app-routing.module.ts`, чтобы добавить маршрут для компонента `RecipesListComponent`:

```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { RecipesListComponent } from './recipes/recipes-list/recipes-list.component';

const routes: Routes = [
  { path: '', redirectTo: 'recipes', pathMatch: 'full' },
  { path: 'recipes', component: RecipesListComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}
```
### Шаг 5: Обновление главного компонента
Обновите шаблон `src/app/app.component.html`, чтобы включить маршрутизацию:
  
```html

<router-outlet></router-outlet>

```
### Шаг 6: Проверка
Запустите сервер и приложение:

```

// Запуск сервера (если еще не запущен)

cd server

npm start

  

// Запуск приложения

cd recipes-app

ng serve

```

Откройте браузер по адресу `http://localhost:4200/recipes`. Вы должны увидеть таблицу с рецептами, загруженными с сервера.
## Управление подписками и использование `async` pipe
Одна из ключевых проблем при работе с `Observable` — это управление подписками. Неправильное управление может привести к **утечкам памяти**, когда подписки остаются активными после уничтожения компонента. В нашем примере мы использовали `async` pipe, который автоматически управляет подписками, но давайте разберем альтернативы и лучшие практики.
### Альтернатива: Явная подписка
Вместо `async` pipe можно явно подписаться в компоненте:

```typescript
import { Component, OnInit, OnDestroy } from '@angular/core';
import { Subscription } from 'rxjs';
import { Recipe } from '../recipe.model';
import { RecipesService } from '../recipes.service';

@Component({
  selector: 'app-recipes-list',
  templateUrl: './recipes-list.component.html',
  styleUrls: ['./recipes-list.component.scss']
})
export class RecipesListComponent implements OnInit, OnDestroy {
  recipes: Recipe[] = [];
  private subscription!: Subscription;

  constructor(private recipesService: RecipesService) {}

  ngOnInit(): void {
    this.subscription = this.recipesService.getRecipes().subscribe({
      next: (recipes) => {
        this.recipes = recipes;
      },
      error: (error) => {
        console.error(error.message);
      }
    });
  }

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }
}

```

Шаблон будет выглядеть так:

```html
<p-table [value]="recipes" [tableStyle]="{ 'min-width': '50rem' }">
  <!-- Остальной код тот же -->
</p-table>
```

Этот подход:
- Требует явной подписки в `ngOnInit`.
- Требует отписки в `ngOnDestroy` для предотвращения утечек памяти.
- Менее предпочтителен, так как `async` pipe упрощает код и автоматически управляет подписками.
### Преимущества `async` pipe
Использование `async` pipe имеет следующие преимущества:
- **Автоматическое управление подписками**: `async` pipe подписывается на `Observable` при рендеринге шаблона и автоматически отписывается при уничтожении компонента.
- **Чистый код**: Устраняет необходимость в явных подписках и отписках.
- **Реактивность**: Автоматически обновляет шаблон при изменении данных в потоке.
### Когда использовать явную подписку
Явная подписка может быть полезна в следующих случаях:
- Выполнение побочных эффектов, которые не связаны с шаблоном (например, запись в консоль или вызов другого метода).
- Сложная логика обработки данных, которую сложно реализовать в шаблоне.

Однако даже в этих случаях можно использовать операторы RxJS, такие как `tap`, для побочных эффектов, сохраняя преимущества `async` pipe.
## Распространенные ошибки и лучшие практики
При работе с получением данных в виде потоков разработчики часто допускают ошибки, которые могут повлиять на производительность и надежность приложения. Вот несколько распространенных ошибок и рекомендации по их избежанию:
### Ошибка 1: Забытые отписки
Если вы используете явные подписки, но забываете отписаться в `ngOnDestroy`, это может привести к утечкам памяти. **Решение**: Всегда реализуйте `ngOnDestroy` для отписки или используйте `async` pipe.
### Ошибка 2: Игнорирование ошибок
Если не обрабатывать ошибки в HTTP-запросах, поток завершится, и пользователь не получит обратной связи. **Решение**: Всегда используйте `catchError` для обработки ошибок и предоставления пользовательских сообщений.
### Ошибка 3: Неправильное использование `map`
Некоторые разработчики используют `map` для побочных эффектов вместо `tap`. **Решение**: Используйте `map` для преобразования данных и `tap` для побочных эффектов, таких как логирование:

```typescript
getRecipes(): Observable<Recipe[]> {
  return this.http.get<Recipe[]>(`${API_URL}/recipes`).pipe(
    tap(response => console.log('Получены рецепты:', response)), // Побочный эффект
    map(response => response.sort((a, b) => b.rating - a.rating)), // Преобразование
    catchError(this.handleError)
  );
}
```
### Лучшие практики
1. **Используйте `async` pipe** везде, где это возможно, для упрощения кода и предотвращения утечек памяти.
2. **Обрабатывайте ошибки** с помощью `catchError` и предоставляйте пользователю понятные сообщения.
3. **Типизируйте данные** с помощью TypeScript-интерфейсов (например, `Recipe`) для строгой типизации.
4. **Минимизируйте побочные эффекты** в операторах `map` и используйте `tap` для логирования или других действий.
5. **Тестируйте потоки** с помощью инструментов, таких как `jasmine-marbles`, для проверки поведения `Observable` (подробнее в главе 13).
## Резюме
В этой главе мы изучили реактивный паттерн для получения данных в виде потоков и реализовали функциональность загрузки списка рецептов в нашем приложении. Мы создали сервис для выполнения HTTP-запросов, компонент для отображения данных и использовали `async` pipe для управления потоками. Также мы обсудили, как правильно управлять подписками, избегать утечек памяти и следовать лучшим практикам.

Теперь, когда мы освоили базовый паттерн получения данных, мы готовы перейти к обработке ошибок. В следующей главе, **"Реактивная обработка ошибок"**, мы изучим различные стратегии обработки ошибок и реализуем их в нашем приложении для повышения надежности.

> **Совет**  
> Убедитесь, что ваш сервер работает, и протестируйте функциональность загрузки рецептов. Попробуйте добавить оператор `tap` в сервис для логирования ответа сервера и проверьте, как `async` pipe обновляет таблицу при получении данных.