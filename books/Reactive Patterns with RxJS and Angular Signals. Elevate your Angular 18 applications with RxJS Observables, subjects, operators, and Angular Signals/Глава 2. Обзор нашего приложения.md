В предыдущей главе мы заложили фундамент, изучив основы реактивного программирования, мраморные диаграммы и использование RxJS в Angular. Теперь пришло время познакомиться с приложением, которое мы будем разрабатывать на протяжении всей книги. Это приложение станет нашей площадкой для реализации всех реактивных паттернов, которые мы будем изучать в последующих главах.

  

В этой главе мы рассмотрим архитектуру нашего приложения, его требования и структуру. Мы начнем с описания приложения и его основных функций. Затем мы разберем требования к серверной части и определим, как данные будут передаваться между клиентом и сервером. Наконец, мы настроим проект и познакомимся с его структурой, чтобы подготовиться к реализации реактивных паттернов.

  

Мы рассмотрим следующие темы:
- Описание приложения для рецептов

- Требования к серверной части

- Настройка проекта

  

## Технические требования

  

Для работы с этой главой вам потребуется следующее программное обеспечение и окружение:

  

| Программное обеспечение/аппаратное обеспечение | Требования к ОС |
|-----------------------------------------------|-------------------------|
| Angular 17 и выше                              | Windows, macOS, Linux   |
| TypeScript 5.4.2                                    | Windows, macOS, Linux   |
| RxJS 7.8.1                                              | Windows, macOS, Linux   |
| PrimeNG 17.10.0                                   | Windows, macOS, Linux   |
| Bootstrap 5.0.0                                      | Windows, macOS, Linux   |
| Node.js 20.x                                           | Windows, macOS, Linux   |

  

Убедитесь, что у вас настроено окружение в соответствии с инструкциями по установке Angular CLI, доступными по адресу: [https://angular.dev/tools/cli/setup-local](https://angular.dev/tools/cli/setup-local). Вам также понадобится установленный Node.js и npm.

  

Мы будем использовать следующие библиотеки:

  

- **Bootstrap** для обеспечения адаптивного дизайна.

- **PrimeNG** для предоставления богатых UI-компонентов, таких как таблицы, выпадающие списки и формы.

- **RxJS** как основную библиотеку для реактивного программирования.

  

Код для этой главы доступен в репозитории GitHub по адресу: [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition). Вы можете клонировать репозиторий и следовать инструкциям в файле `README.md` для настройки проекта.

  

Кроме того, для имитации серверной части мы будем использовать готовый сервер, доступный в том же репозитории. Инструкции по запуску сервера также приведены в `README.md`.

  

> **Примечание**  

> Если вы используете цифровую версию книги, мы рекомендуем набирать код вручную или использовать файлы из репозитория GitHub, чтобы избежать ошибок, связанных с копированием и вставкой.

  

## Описание приложения для рецептов

  

Наше приложение — это **приложение для управления рецептами**, которое позволяет пользователям просматривать, создавать, редактировать и удалять кулинарные рецепты. Оно предназначено для демонстрации реактивных паттернов в реальном контексте, поэтому мы будем использовать его для реализации всех концепций, описанных в книге.

  

Приложение будет включать следующие ключевые функции:

  

- **Просмотр списка рецептов**: Пользователи смогут просматривать список всех рецептов в виде таблицы с возможностью фильтрации и сортировки.

- **Создание нового рецепта**: Пользователи смогут добавлять новые рецепты через форму, включая такие поля, как название, ингредиенты, инструкции и рейтинг.

- **Редактирование рецепта**: Пользователи смогут обновлять существующие рецепты.

- **Удаление рецепта**: Пользователи смогут удалять рецепты из списка.

- **Фильтрация и поиск**: Пользователи смогут фильтровать рецепты по категориям (например, десерты, основные блюда) или искать по ключевым словам.

- **Автосохранение и автодополнение**: Формы будут поддерживать автосохранение введенных данных и автодополнение для ингредиентов.

- **Обновления в реальном времени**: Новые рецепты или изменения будут отображаться в интерфейсе мгновенно.

- **Массовые операции**: Пользователи смогут загружать несколько рецептов одновременно через массовую загрузку файлов.

  

Эти функции охватывают широкий спектр сценариев, которые идеально подходят для демонстрации реактивных паттернов, таких как обработка потоков данных, управление ошибками, комбинирование потоков и кэширование.

  

### Архитектура приложения

  

Архитектура приложения будет следовать стандартным практикам Angular:

  

- **Компоненты**: Основной интерфейс будет состоять из компонентов, таких как `RecipesListComponent` (список рецептов), `RecipeFormComponent` (форма для создания/редактирования рецепта) и `RecipeFilterComponent` (фильтрация и поиск).

- **Сервисы**: Логика работы с данными будет вынесена в сервисы, такие как `RecipesService`, который будет использовать `HttpClient` для взаимодействия с сервером.

- **Модели**: Данные будут представлены в виде TypeScript-интерфейсов, таких как `Recipe`, для строгой типизации.

- **Модули**: Приложение будет организовано в модули, такие как `RecipesModule`, для инкапсуляции функциональности.

  

Вот пример интерфейса `Recipe`, который будет использоваться в приложении:

  

```typescript

export interface Recipe {

  id: number;

  title: string;

  ingredients: string[];

  instructions: string;

  category: string;

  rating: number;

  createdAt: string;

}

```

  

Этот интерфейс определяет структуру данных рецепта, которая будет использоваться для обмена данными между клиентом и сервером.

  

### Интерфейс пользователя

  

Интерфейс приложения будет построен с использованием **PrimeNG** и **Bootstrap** для создания современного и отзывчивого дизайна. Основной экран будет включать:

  

- **Таблицу рецептов**: Отображает список рецептов с колонками для названия, категории, рейтинга и даты создания.

- **Форму рецепта**: Форма для добавления или редактирования рецепта с полями для ввода названия, ингредиентов, инструкций и выбора категории.

- **Панель фильтрации**: Выпадающие списки и поле поиска для фильтрации рецептов.

- **Кнопки действий**: Кнопки для создания, редактирования и удаления рецептов.

  

Пример HTML-шаблона для компонента списка рецептов:

  

```html

<p-table [value]="recipes" [tableStyle]="{ 'min-width': '50rem' }">

  <ng-template pTemplate="header">

    <tr>

      <th>Название</th>

      <th>Категория</th>

      <th>Рейтинг</th>

      <th>Действия</th>

    </tr>

  </ng-template>

  <ng-template pTemplate="body" let-recipe>

    <tr>

      <td>{{ recipe.title }}</td>

      <td>{{ recipe.category }}</td>

      <td>{{ recipe.rating }}</td>

      <td>

        <button pButton label="Редактировать" (click)="editRecipe(recipe)"></button>

        <button pButton label="Удалить" (click)="deleteRecipe(recipe)"></button>

      </td>

    </tr>

  </ng-template>

</p-table>

```

  

Этот шаблон использует компонент `p-table` из PrimeNG для отображения списка рецептов в виде таблицы.

  

## Требования к серверной части

  

Для имитации реального приложения мы будем использовать серверную часть, которая предоставляет REST API для управления рецептами. Сервер уже настроен и доступен в репозитории GitHub, упомянутом ранее. Он написан на Node.js с использованием Express и предоставляет следующие конечные точки (endpoints):

  

| Метод | Конечная точка            | Описание                              |

|-------|---------------------------|---------------------------------------|

| GET   | `/api/recipes`            | Получение списка всех рецептов        |

| GET   | `/api/recipes/:id`        | Получение рецепта по ID               |

| POST  | `/api/recipes`            | Создание нового рецепта               |

| PUT   | `/api/recipes/:id`        | Обновление существующего рецепта      |

| DELETE| `/api/recipes/:id`        | Удаление рецепта по ID                |

| POST  | `/api/recipes/bulk`       | Массовая загрузка рецептов            |

| GET   | `/api/recipes/categories` | Получение списка категорий рецептов   |

  

### Формат данных

  

Сервер ожидает и возвращает данные в формате JSON. Например, ответ на запрос `GET /api/recipes` будет выглядеть следующим образом:

  

```json

[

  {

    "id": 1,

    "title": "Шоколадный торт",

    "ingredients": ["мука", "сахар", "какао", "яйца"],

    "instructions": "Смешать ингредиенты, выпекать 30 минут при 180°C.",

    "category": "Десерт",

    "rating": 4.5,

    "createdAt": "2023-10-01T10:00:00Z"

  },

  {

    "id": 2,

    "title": "Паста Карбонара",

    "ingredients": ["спагетти", "бекон", "яйца", "пармезан"],

    "instructions": "Сварить пасту, приготовить соус, смешать.",

    "category": "Основное блюдо",

    "rating": 4.8,

    "createdAt": "2023-10-02T12:00:00Z"

  }

]

```

  

Для создания или обновления рецепта клиент должен отправить JSON-объект, соответствующий интерфейсу `Recipe`.

  

### Асинхронные обновления

  

Сервер поддерживает обновления в реальном времени через WebSocket (для демонстрации в главе 12). Когда новый рецепт создается или существующий обновляется, сервер отправляет уведомление всем подключенным клиентам, чтобы они могли обновить интерфейс без перезагрузки страницы.

  

## Настройка проекта

  

Теперь, когда мы понимаем архитектуру и требования, давайте настроим проект и познакомимся с его структурой.

  

### Шаг 1: Установка Angular CLI

  

Если у вас еще не установлен Angular CLI, выполните следующую команду в терминале:

  

```

// Установка Angular CLI глобально

npm install -g @angular/cli

```

  

### Шаг 2: Создание нового проекта

  

Создайте новый Angular-проект с помощью команды:

  

```

// Создание проекта

ng new recipes-app --style=scss --routing=true

```

  

Эта команда создаст новый проект с поддержкой SCSS и модуля маршрутизации.

  

### Шаг 3: Установка зависимостей

  

Перейдите в папку проекта и установите необходимые зависимости:

  

```

// Переход в папку проекта

cd recipes-app

  

// Установка Bootstrap

npm install bootstrap

  

// Установка PrimeNG

npm install primeng primeicons

  

// Установка RxJS (обычно уже включен в Angular)

npm install rxjs

```

  

После установки добавьте стили Bootstrap и PrimeNG в файл `angular.json`:

  

```json

"styles": [

  "node_modules/bootstrap/dist/css/bootstrap.min.css",

  "node_modules/primeicons/primeicons.css",

  "node_modules/primeng/resources/themes/lara-light-blue/theme.css",

  "node_modules/primeng/resources/primeng.min.css",

  "src/styles.scss"

]

```

  

### Шаг 4: Настройка модуля PrimeNG

  

Создайте модуль для импорта компонентов PrimeNG. Например, создайте файл `src/app/primeng.module.ts`:

  

```typescript

import { NgModule } from '@angular/core';

import { TableModule } from 'primeng/table';

import { ButtonModule } from 'primeng/button';

import { InputTextModule } from 'primeng/inputtext';

import { DropdownModule } from 'primeng/dropdown';

  

@NgModule({

  imports: [

    TableModule,

    ButtonModule,

    InputTextModule,

    DropdownModule

  ],

  exports: [

    TableModule,

    ButtonModule,

    InputTextModule,

    DropdownModule

  ]

})

export class PrimeNgModule {}

```

  

Импортируйте этот модуль в главный модуль приложения (`src/app/app.module.ts`):

  

```typescript

import { NgModule } from '@angular/core';

import { BrowserModule } from '@angular/platform-browser';

import { HttpClientModule } from '@angular/common/http';

import { AppRoutingModule } from './app-routing.module';

import { AppComponent } from './app.component';

import { PrimeNgModule } from './primeng.module';

  

@NgModule({

  declarations: [AppComponent],

  imports: [

    BrowserModule,

    HttpClientModule,

    AppRoutingModule,

    PrimeNgModule

  ],

  bootstrap: [AppComponent]

})

export class AppModule {}

```

  

### Шаг 5: Настройка сервера

  

Склонируйте репозиторий GitHub и следуйте инструкциям в `README.md` для запуска сервера. Обычно это включает выполнение следующих команд:

  

```

// Клонирование репозитория

git clone https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition.git

  

// Переход в папку сервера

cd server

  

// Установка зависимостей

npm install

  

// Запуск сервера

npm start

```

  

Сервер будет запущен по адресу `http://localhost:3000`.

  

### Шаг 6: Структура проекта

  

После настройки проект будет иметь следующую структуру:

  

```

recipes-app/

├── src/

│   ├── app/

│   │   ├── primeng.module.ts

│   │   ├── app.component.ts

│   │   ├── app.module.ts

│   │   ├── app-routing.module.ts

│   │   ├── recipes/

│   │   │   ├── recipes-list/

│   │   │   ├── recipe-form/

│   │   │   ├── recipe-filter/

│   │   │   ├── recipes.service.ts

│   │   │   ├── recipe.model.ts

│   ├── assets/

│   ├── styles.scss

├── angular.json

├── package.json

```

  

- **Папка `recipes`**: Содержит компоненты и сервисы, связанные с функциональностью рецептов.

- **Файл `recipe.model.ts`**: Определяет интерфейс `Recipe`.

- **Файл `recipes.service.ts`**: Содержит логику для взаимодействия с сервером.

- **Папка `assets`**: Для хранения статических ресурсов, таких как изображения.

  

### Шаг 7: Проверка запуска

  

Запустите приложение, чтобы убедиться, что оно работает:

  

```

// Запуск приложения

ng serve

```

  

Откройте браузер и перейдите по адресу `http://localhost:4200`. Вы должны увидеть начальный шаблон Angular.

  

## Резюме

  

В этой главе мы познакомились с приложением для управления рецептами, которое будем разрабатывать на протяжении книги. Мы описали его ключевые функции, архитектуру и интерфейс пользователя. Затем мы определили требования к серверной части, включая REST API и формат данных. Наконец, мы настроили проект, установили зависимости и рассмотрели его структуру.

  

Теперь, когда у нас есть настроенное приложение, мы готовы приступить к реализации реактивных паттернов. В следующей главе, **"Получение данных в виде потоков"**, мы начнем с изучения реактивного паттерна для получения данных и реализуем функциональность загрузки списка рецептов с сервера с использованием RxJS.

  

> **Совет**  

> Убедитесь, что вы клонировали репозиторий GitHub и запустили сервер, чтобы следовать примерам в следующих главах. Это позволит вам тестировать код в реальном времени.